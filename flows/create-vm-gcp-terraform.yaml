id: create-vm-gcp-terraform
namespace: solutions.infra
description: >
  Create a VM on Google Cloud by generating a hostname, reserving an IP from an
  external IPAM, provisioning the instance via Terraform, and notifying Slack
  with the resulting details.

inputs:
  - id: cloudProvider
    displayName: Cloud Provider
    type: SELECT
    values:
      - AWS
      - GCP
      - Azure
      - VCF
    defaults: GCP

  - id: billingAccount
    type: SELECT
    displayName: Billing Account
    description: |
      This is typically your
      Account ID for AWS
      Project ID for GCP
      Subscription ID for Azure
    values:
      - sandbox
      - dev
    defaults: sandbox
    dependsOn:
      inputs:
        - cloudProvider
      condition: "{{ inputs.cloudProvider == 'GCP' }}"

  - id: region
    type: SELECT
    displayName: Region
    values:
      - us-central1
      - us-east1
    dependsOn:
      inputs:
        - billingAccount
      condition: "{{ inputs.billingAccount == 'kestra-sandbox' }}"
    defaults: us-central1

  - id: zone
    type: SELECT
    displayName: Zone
    values:
      - us-central1-a
      - us-central1-b
    dependsOn:
      inputs:
        - region
      condition: "{{ inputs.region == 'us-central1' }}"
    defaults: us-central1-a

  - id: os
    displayName: Operating System
    type: SELECT
    values:
      - Windows
      - Linux
    defaults: Linux

  - id: osFlavor
    displayName: OS Version
    type: SELECT
    values:
      - Ubuntu 24.04
      - Ubuntu 20.04
      - ubuntu-minimal-2210-kinetic-amd64-v20230126
    defaults: ubuntu-minimal-2210-kinetic-amd64-v20230126
    dependsOn:
      inputs:
        - os
      condition: "{{ inputs.os == 'Linux' }}"

  - id: vmSize
    displayName: VM Size
    type: SELECT
    values:
      - Small
      - Medium
      - Large
      - n1-standard-1
    description: |
      Small   - 2 vCPUs 4 GB RAM
      Medium  - 4 vCPUs 8 GB RAM
      Large   - 8 vCPUs 16 GB RAM
    defaults: n1-standard-1

  - id: network
    displayName: Network
    type: SELECT
    values:
      - demo-vpc
      - vpc-02
    defaults: demo-vpc

  - id: subnet
    displayName: Subnet
    type: SELECT
    values:
      - demo-vpc
      - subnet-02
    defaults: demo-vpc

  - id: vmType
    type: SELECT
    displayName: Type of VM
    values:
      - Application
      - Database
      - Server
    defaults: Application

  - id: env
    type: SELECT
    displayName: Environment
    values:
      - Development
      - Staging
      - Production
    defaults: Development

tasks:
  - id: generateCustomHostname
    type: io.kestra.plugin.scripts.python.Script
    beforeCommands:
      - pip install kestra
    script: |
      from kestra import Kestra

      try:
          cloud_code = "{{ inputs.cloudProvider | slice(0, 3) }}"
          env_code = "{{ inputs.env | slice(0, 3) }}"
          os_code = "{{ inputs.os | slice(0, 3) }}"
          vm_code = "{{ inputs.vmType | slice(0, 3) }}"
          index_code = {{ kv('getVMIndex', errorOnMissing = false) ?? 1 }}

          vm_name = f"{cloud_code}{env_code}{os_code}{vm_code}{index_code}"

          Kestra.outputs({'customHostname': vm_name.lower(), 'index_code': index_code})

      except KeyError as e:
          print(f"Invalid value for input: {e}")
      except Exception as e:
          print(str(e))

  - id: getIPAddress
    type: io.kestra.plugin.scripts.python.Script
    beforeCommands:
      - pip install requests kestra
    script: |
      from kestra import Kestra
      import requests

      IPAM_BASE_URL = "{{ kv('ipamAddress', errorOnMissing = false) ?? 'localhost' }}/api/dev-ipam"
      endpoint = f"subnets/{{inputs.subnet}}/first_free"

      response = requests.get(f"{IPAM_BASE_URL}/{endpoint}", verify=False)
      print(response.status_code)
      ip_address = response.json().get("ipAddress")
      Kestra.outputs({'status': response.status_code, 'ipAddress': ip_address})

  - id: createVM
    type: io.kestra.plugin.terraform.cli.TerraformCLI
    inputFiles:
      main.tf: |
        resource "google_compute_instance" "default" {
          name         = "{{ outputs.generateCustomHostname.vars.customHostname }}"
          machine_type = "{{ inputs.vmSize }}"
          zone         = "{{ inputs.zone }}"
          project      = "{{ inputs.billingAccount }}"

          boot_disk {
            initialize_params {
              image = "{{ inputs.osFlavor }}"
            }
          }

          network_interface {
            network            = "{{ inputs.network }}"
            subnetwork         = "{{ inputs.subnet }}"
            subnetwork_project = "{{ inputs.billingAccount }}"
            access_config {}
            network_ip = "{{ outputs.getIPAddress.vars.ipAddress }}"
          }

          metadata = {
            enable-oslogin = false
            "ssh-keys" = <<EOT
              root:{{ secret('SSH_PUB_KEY') }}
            EOT
          }
        }

        output "external_ip" {
          value       = google_compute_instance.default.network_interface[0].access_config[0].nat_ip
          description = "The external IP address of the VM"
        }
      gcp-svc-account.json: "{{ secret('GCP_SVC_ACCOUNT') }}"
    env:
      GOOGLE_APPLICATION_CREDENTIALS: gcp-svc-account.json
    beforeCommands:
      - terraform init
    commands:
      - terraform plan
      - terraform apply -auto-approve -json
      - terraform output -raw external_ip > external_ip.txt
    allowFailure: false
    outputFiles:
      - "*.txt"

  - id: notifyChannel
    type: io.kestra.plugin.slack.SlackIncomingWebhook
    url: "{{ secret(namespace='system', key='SLACK_WEBHOOK') }}"
    messageText: |
      {
        "text": "{{ outputs.generateCustomHostname.vars.customHostname }} created successfully with the following properties\n ExternalIPAddress: {{ read(outputs.createVM.outputFiles['external_ip.txt']) }}\n DefaultUser: {{ secret('SSH_VM_USER') }}\n Cloud: {{ inputs.cloudProvider }}\n Account: {{ inputs.billingAccount }}\n Region: {{ inputs.region }}\n Zone: {{ inputs.zone }}\n Network: {{ inputs.network }}\n Subnet: {{ inputs.subnet }}\n Size: {{ inputs.vmSize }}\n OS: {{ inputs.os }}\n Version: {{ inputs.osFlavor }}\n Environment: {{ inputs.env }}\n VMType: {{ inputs.vmType }}\n IPAddress: {{ outputs.getIPAddress['vars']['ipAddress'] }}\n"
      }

  - id: incrementindex
    type: io.kestra.plugin.core.kv.Set
    key: getVMIndex
    kvType: NUMBER
    value: "{{ outputs.generateCustomHostname.vars.index_code + 1 }}"
    allowFailure: true

outputs:
  - id: externalIPAddress
    type: STRING
    value: "{{ read(outputs.createVM.outputFiles['external_ip.txt']) ?? 'Failed' }}"

extend:
  title: Provision Google Cloud VMs with Terraform, IPAM, and Slack Notifications
  description: |
    This workflow demonstrates an **enterprise-grade Infrastructure as Code
    (IaC) pattern** for provisioning **Google Cloud Compute Engine virtual
    machines** using **Terraform**, integrated **IP address management (IPAM)**,
    and automated **Slack notifications**.

    It shows how to:

    1. Dynamically generate standardized VM hostnames based on cloud provider,
       environment, operating system, and workload type.
    2. Reserve IP addresses automatically from an external IPAM system to
       enforce network governance and avoid address conflicts.
    3. Provision Google Cloud virtual machines declaratively using Terraform
       with inline configuration files.
    4. Parameterize VM creation with selectable regions, zones, machine types,
       operating systems, networks, and environments.
    5. Notify teams in Slack with detailed provisioning results, including
       external IP address, configuration metadata, and access information.
    6. Maintain stateful VM indexing using Kestra key-value storage to ensure
       predictable and collision-free resource naming.

    This blueprint is ideal for **cloud infrastructure teams**, **platform
    engineers**, and **DevOps organizations** looking to standardize VM
    provisioning on Google Cloud while integrating networking controls,
    automation, and operational visibility.

    By combining Terraform, IPAM, and orchestration in a single workflow, this
    flow enables repeatable, auditable, and scalable VM provisioning aligned
    with modern cloud governance practices.
  tags:
    - Infrastructure
  ee: false
  demo: false
  meta_description: |
    Provision Google Cloud VMs using Terraform with IPAM-backed networking and
    Slack notifications. An Infrastructure as Code workflow for standardized,
    governed VM creation on GCP.
