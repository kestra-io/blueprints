id: tcp-send-example
namespace: company.team

inputs:
  - id: host
    type: STRING
    defaults: "127.0.0.1"
    description: Target TCP host or IP address that accepts the message.
  - id: port
    type: INT
    defaults: 9090
    description: TCP port on the destination host.
  - id: payload
    type: STRING
    defaults: "Hello from Kestra"
    description: Message body to send to the TCP service.

tasks:
  - id: check_port
    type: io.kestra.plugin.scripts.shell.Commands
    description: Verify the TCP port is reachable before sending the payload.
    commands:
      - bash -lc "cat < /dev/null >/dev/tcp/{{ inputs.host }}/{{ inputs.port }}"

  - id: log_inputs
    type: io.kestra.plugin.core.log.Log
    message: "Sending TCP payload '{{ inputs.payload }}' to {{ inputs.host }}:{{ inputs.port }}"

  - id: send_tcp
    type: io.kestra.plugin.fs.tcp.Send
    description: Send a payload to a TCP endpoint (ideal for echo servers or custom services).
    host: "{{ inputs.host }}"
    port: "{{ inputs.port }}"
    payload: "{{ inputs.payload }}"

  - id: assert_send
    type: io.kestra.plugin.core.execution.Assert
    description: Fail fast if the TCP send task did not produce an output map.
    conditions:
      - "{{ outputs.send_tcp is not null }}"

extend:
  title: Send a TCP message to a remote host for network checks and infrastructure automation
  description: |
    Send a raw TCP message (ping-style payload) to any host and port using Kestra.  
    This blueprint is designed for **network validation, infrastructure automation, and service health checks** where HTTP is not available or not appropriate.

    It is ideal for interacting with **TCP-based services**, including echo servers, legacy daemons, internal appliances, custom socket listeners, and low-level system components.

    **Key use cases**
    - Validate that a TCP port is open and reachable before running downstream workflows
    - Smoke-test infrastructure after deployment (VMs, containers, load balancers)
    - Send handshake or heartbeat messages to custom TCP services
    - Automate network and firewall verification in CI/CD pipelines
    - Integrate with legacy systems that expose only raw TCP sockets

    **What this flow does**
    - Performs a lightweight TCP connectivity check before sending data
    - Logs the destination and payload for observability and auditability
    - Sends a custom payload over a TCP socket
    - Fails fast if the send operation does not succeed (CI-friendly)

    **How it works**
    1. **check_port** verifies that the target `host:port` is reachable using a TCP probe
    2. **log_inputs** records the destination and message being sent
    3. **send_tcp** opens a TCP socket and transmits the payload
    4. **assert_send** ensures the TCP send produced an output, failing the execution otherwise

    **Inputs**
    - `host`: target hostname or IP address (default: `127.0.0.1`)
    - `port`: TCP port to connect to (default: `9090`)
    - `payload`: message sent to the TCP service (default: `Hello from Kestra`)

    **Outputs**
    - `outputs.send_tcp`: connection and send metadata returned by the TCP plugin

    **Local testing**
    You can test this blueprint locally by running a TCP echo server:
    - `docker run --rm -p 9090:9090 alpine/socat -v tcp-listen:9090,reuseaddr,fork system:'cat'`

    **Notes**
    - No authentication or secrets are required for basic TCP messaging
    - TLS, encryption, or authentication should be handled externally if needed
    - Works well as a pre-flight or guardrail step in infrastructure workflows
  tags:
    - Infrastructure
    - Core
  ee: false
  demo: false
  meta_description: Send a TCP message to any host and port with Kestra. Perform network checks, validate open ports, smoke-test infrastructure, and automate TCP-based service interactions.
